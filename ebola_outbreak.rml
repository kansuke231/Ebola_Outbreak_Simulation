
(********************************************************************)
(*  Status  *)
(********************************************************************)
type status =
	| Susceptible
	| Exposed
	| Infectious
	| Removed



(********************************************************************)
(* Direction                                                        *)
(********************************************************************)
type dir =
  | Up
  | Down
  | Left
  | Right
  | Up_Left
  | Up_Right
  | Down_Left
  | Down_Right
  | Long_Lange

let opposite dir =
  match dir with
  | Up -> Down
  | Down -> Up
  | Left -> Right
  | Right -> Left
  | Up_Left -> Down_Right
  | Up_Right -> Down_Left
  | Down_Left -> Up_Right
  | Down_Right -> Up_Left
  | Long_Lange -> Long_Lange

(********************************************************************)
(* Info                                                             *)
(********************************************************************)

type 'a info =
    { origin: dir;
      status: status;
    }
(**************************************************************************)
(* neighborhood                                                           *)
(**************************************************************************)

type 'a neighborhood = 'a info list

(********************************************************************)
(* Constantes                                                       *)
(********************************************************************)
let maxx = ref 300
let maxy = ref 300

let nox = ref false
let zoom = ref 2

let delta = 3 (* steps for E -> I *)
let gamma = 15 (* steps for I -> R *)



(**************************************************************************)
(* cell                                                                   *)
(**************************************************************************)


type 'a cell =
    { cell_x: int;
      cell_y: int;
      cell_activation: ('a info, 'a info list) event;
      mutable cell_status: status;
      mutable cell_neighborhood: (dir * ('a info , 'a info list) event) list;
      mutable time: int;
      mutable exposed_time: int;
      mutable infectious_time: int;
    }

let make_info origin cell =
  { origin = origin;
    status = cell.cell_status;
  }

let new_cell x y activation status =
  { cell_x = x;
    cell_y = y;
    cell_activation = activation;
    cell_status = status;
    cell_neighborhood = [];
    time = 0;
	exposed_time = 0;
	infectious_time = 0;
  }

let draw_cell_gen color_of_cell c =
  Graphics.set_color (color_of_cell c);
  Graphics.fill_rect (c.cell_x * !zoom) (c.cell_y * !zoom) !zoom !zoom

let color_of_status s =
  match s.cell_status with
  | Susceptible -> Graphics.blue
  | Exposed -> Graphics.green
  | Infectious -> Graphics.red
  | Removed -> Graphics.white

(**************************************************************************)
(* neighborhood functions                                                 *)
(**************************************************************************)
let get_von_neumann_neighbors cell cell_array =
  let x = cell.cell_x in
  let y = cell.cell_y in
  let neighbors = ref [] in
  if 0 <= x-1 then neighbors := (Left, cell_array.(x-1).(y)) :: !neighbors;
  if x+1 < !maxx then neighbors := (Right, cell_array.(x+1).(y)) :: !neighbors;
  if 0 <= y-1 then neighbors := (Down, cell_array.(x).(y-1)) :: !neighbors;
  if y+1 < !maxy then neighbors := (Up, cell_array.(x).(y+1)) :: !neighbors;
  !neighbors


(**************************************************************************)
(* cell process                                                           *)
(**************************************************************************)

let rec activate_neighborhood self neighbors =
  match neighbors with
  | [] -> ()
  | (dir, activation_sig) :: neighbors ->
      let info = make_info (opposite dir) self in
      emit activation_sig info;
      activate_neighborhood self neighbors
      (*Note that there is not "pause". which means this recursive function emits
        a signal for eveyry neighbor of self and awaiting this signal catches a list of
        signals emitted during the instant (so it's list)*)

let rec long_range_interaction cell cell_array =
	let maxx = !maxx in 
	let maxy = !maxy in
	let x = cell.cell_x  in
  	let y = cell.cell_y  in
  	let rand_x = Random.int maxx in
  	let rand_y = Random.int maxy in
  	if (x <> rand_x)&&(y <> rand_y) 
  		then (Long_Lange, cell_array.(rand_x).(rand_y))
  	else long_range_interaction cell cell_array


let process cell draw_cell get_neighbors cell_behavior
    x y status_init cell_array =
  signal activation in
  let self = new_cell x y activation status_init in
  cell_array.(x).(y) <- activation; (* At first, cell_array.(x).(y) contains a signal "temp". This line puts a new signal "activation"*)
  draw_cell self;
  pause;
  self.cell_neighborhood <- get_neighbors self cell_array;
  loop
  	(*interaction with four neighbors in a day*)
  	let faraway = long_range_interaction self cell_array in 
    activate_neighborhood self (self.cell_neighborhood @ [faraway]);
    pause;
    let neighbors = pre ?activation in
    cell_behavior self neighbors;
    draw_cell self;
    self.time <- self.time + 1
  end


(**************************************************************************)
(* cell behaviors                                                         *)
(**************************************************************************)
let ebola cell neighbors =
	let result = ref Susceptible in 
	List.iter
	  (fun info -> if (info.status = Infectious)&& Random.float 1.0 < 0.1 then result := Exposed)
	  neighbors;
	  cell.cell_status <-
	  	match cell.cell_status with
	  	| Susceptible -> if !result = Exposed then (cell.exposed_time <- cell.time; Exposed) else Susceptible
	  	| Exposed ->     if (cell.time - cell.exposed_time) < delta then Exposed else (cell.infectious_time <- cell.time; Infectious)
	  	| Infectious ->  if (cell.time - cell.infectious_time) < gamma then Infectious else Removed
	  	| Removed -> 	 Removed
	  	


(**************************************************************************)
(* cellular automaton                                                     *)
(**************************************************************************)
let cell_array_create tmp =
  Array.make_matrix !maxx !maxy tmp

let get_status i j =
	(* For testing the long-range infection *)
	(*if (i = 100)&&(j = 100) then Infectious, () else Susceptible, ()*)
	if Random.float 1.0 < 0.015 then Infectious else Susceptible


let process cellular_automaton_start
    draw_cell get_neighbors get_status cell_behavior cell_array =
  for i = 0 to !maxx - 1 dopar
    for j = 0 to !maxy - 1 dopar
      run (cell draw_cell get_neighbors cell_behavior
	     i j (get_status i j) cell_array)
    done
  done

(**************************************************************************)
(* main                                                                   *)
(**************************************************************************)



let process main =
	Random.self_init();
	Graphics.open_graph (" "^(string_of_int (!maxx * !zoom))^"x"^
			       (string_of_int (!maxy * !zoom)));
    Graphics.auto_synchronize false;

	signal tmp in
		let cell_array = cell_array_create tmp in
		let draw = draw_cell_gen color_of_status
		in
		run (cellular_automaton_start
		       draw
		       get_von_neumann_neighbors
		       get_status
		       ebola
	       	   cell_array);
		||
		loop
			ignore (Graphics.wait_next_event [Graphics.Poll]);
			Graphics.synchronize ();
			pause;
      	end

let () = run main
