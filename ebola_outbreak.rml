
(********************************************************************)
(*  Status  *)
(********************************************************************)
type status =
	| Susceptible
	| Exposed
	| Infectious
	| Removed

type sector_status = 
  | A  (* Infected *)
  | B
  | C  (* Clean and no adjacent*)

(********************************************************************)
(* Direction                                                        *)
(********************************************************************)
type dir =
  | Up
  | Down
  | Left
  | Right
  | Up_Left
  | Up_Right
  | Down_Left
  | Down_Right
  | Long_Lange

let opposite dir =
  match dir with
  | Up -> Down
  | Down -> Up
  | Left -> Right
  | Right -> Left
  | Up_Left -> Down_Right
  | Up_Right -> Down_Left
  | Down_Left -> Up_Right
  | Down_Right -> Up_Left
  | Long_Lange -> Long_Lange

(********************************************************************)
(* Info                                                             *)
(********************************************************************)

type info =
    { origin: dir;
      status: status;
      sector: int * int;
    }

(**************************************************************************)
(* neighborhood                                                           *)
(**************************************************************************)

type neighborhood = info list

(********************************************************************)
(* Constantes                                                       *)
(********************************************************************)
let maxx = ref 300
let maxy = ref 300

let sectormaxx = ref 10
let sectormaxy = ref 10

let sectorsize = ref (!maxx / !sectormaxx)

let nox = ref false
let zoom = ref 3

let delta = 3 (* steps for E -> I *)
let gamma = 15 (* steps for I -> R *)

(**************************************************************************)
(* cell                                                                   *)
(**************************************************************************)


type cell =
    { cell_x: int;
      cell_y: int;
      cell_activation: (info, info list) event;
      compliant: bool;
      mutable cell_status: status;
      mutable cell_neighborhood: ((dir * cell) list);
      mutable time: int;
      mutable exposed_time: int;
      mutable infectious_time: int;
      mutable sector_id: int * int;
    }

let make_info origin cell =
  { origin = origin;
    status = cell.cell_status;
    sector = cell.sector_id;
  }

let new_cell x y activation status sector_id =
  { cell_x = x;
    cell_y = y;
    cell_activation = activation;
    cell_status = status;
    cell_neighborhood = [];
    time = 0;
	  exposed_time = 0;
	  infectious_time = 0;
    compliant = if (Random.float 1.0) < 0.4 then true else false;
    sector_id = sector_id; (* tuple *)
  }

let draw_cell_gen color_of_cell c =
  Graphics.set_color (color_of_cell c);
  Graphics.fill_rect (c.cell_x * !zoom) (c.cell_y * !zoom) !zoom !zoom;

  if c.cell_x mod !sectormaxx = 0 then (
    Graphics.set_color Graphics.black;
    Graphics.moveto (c.cell_x * !zoom) (c.cell_y * !zoom);
    Graphics.lineto ((c.cell_x ) * !zoom) ((c.cell_y+ 1) * !zoom) 
  )
  else if c.cell_y mod !sectormaxy = 0 then (
    Graphics.set_color Graphics.black;
    Graphics.moveto (c.cell_x * !zoom) (c.cell_y * !zoom);
    Graphics.lineto ((c.cell_x + 1) * !zoom) ((c.cell_y) * !zoom) 
  )

let color_of_status s =
  match s.cell_status with
  | Susceptible -> Graphics.blue
  | Exposed -> Graphics.green
  | Infectious -> Graphics.red;
  | Removed -> Graphics.white

(**************************************************************************)
(* sector                                                                   *)
(**************************************************************************)

type 'a sector = 
    {
    mutable sector_status: sector_status;
    sector_activation: (status, status list) event;
    coordinate: int * int;
    } 

let new_sector status activation coordinate =
  { 
    sector_status = status;
    sector_activation = activation;
    coordinate = coordinate;
  }


(*
let draw_sector s = 
  Graphics.set_color Graphics.black;
  Graphics.draw_rect (s.sector_x * !sectorsize) (s.sector_y * !sectorsize) !sectorsize !sectorsize
*)

(**************************************************************************)
(* sector process                                                         *)
(**************************************************************************)
let process sector coordinate sector_array =
  signal sector_activation in
  let x,y = coordinate in
  let self_sector = new_sector A sector_activation coordinate in
  sector_array.(x).(y) <- self_sector;
  pause;

  loop
    pause;
    let reports = pre ?sector_activation in 
    ()
  end


(**************************************************************************)
(* neighborhood functions                                                 *)
(**************************************************************************)
let get_von_neumann_neighbors cell cell_array =
  let x = cell.cell_x in
  let y = cell.cell_y in
  let neighbors = ref [] in
  if 0 <= x-1 then neighbors := (Left, cell_array.(x-1).(y)) :: !neighbors;
  if x+1 < !maxx then neighbors := (Right, cell_array.(x+1).(y)) :: !neighbors;
  if 0 <= y-1 then neighbors := (Down, cell_array.(x).(y-1)) :: !neighbors;
  if y+1 < !maxy then neighbors := (Up, cell_array.(x).(y+1)) :: !neighbors;
  !neighbors

(* let sector_neighbors sector sector_array =  *)


(**************************************************************************)
(* cell process                                                           *)
(**************************************************************************)

let rec activate_neighborhood self neighbors =
  match neighbors with
  | [] -> ()
  | (dir, cell) :: neighbors' ->
      let info = make_info (opposite dir) self in
      emit cell.cell_activation info;
      activate_neighborhood self neighbors'
      (*Note that there is not "pause". which means this recursive function emits
        a signal for eveyry neighbor of self and awaiting this signal catches a list of
        signals emitted during the instant (so it's list)*)

let rec long_range_interaction cell cell_array =
	let maxx = !maxx in 
	let maxy = !maxy in
	let x = cell.cell_x  in
  	let y = cell.cell_y  in
  	let rand_x = Random.int maxx in
  	let rand_y = Random.int maxy in
  	if (x <> rand_x)&&(y <> rand_y) 
  		then
      let other = cell_array.(rand_x).(rand_y) in
      let other_activation = other.cell_activation in
      emit cell.cell_activation (make_info Long_Lange other);
      emit other_activation (make_info Long_Lange cell)
  	else long_range_interaction cell cell_array


let process cell draw_cell get_neighbors cell_behavior
    x y status_init cell_array sector_array=
  signal activation in
  let sector_id = (x/(!sectormaxx),y/(!sectormaxy)) in 
  let self = new_cell x y activation status_init sector_id in
  cell_array.(x).(y) <- self; (* At first, cell_array.(x).(y) contains a temporary cell. This line puts a new cell into it*)
  draw_cell self;
  pause;
  self.cell_neighborhood <- get_neighbors self cell_array;
  loop
  	long_range_interaction self cell_array;
    (*interaction with four neighbors in a day*)
    activate_neighborhood self (self.cell_neighborhood);

    let sector = sector_array.(fst sector_id).(snd sector_id) in
    emit sector.sector_activation self.cell_status;
    
    pause;
    let interactions = pre ?activation in
    cell_behavior self interactions;
    draw_cell self;
    self.time <- self.time + 1
  end


(**************************************************************************)
(* cell behaviors                                                         *)
(**************************************************************************)
let ebola cell interactions = (* pre-T0 *)
	let result = ref Susceptible in 
	List.iter
	  (fun info -> 
      match info with
      | {origin = Long_Lange; status = Infectious; sector = _} -> 
          (* Long-range interaction in the same sector *)
          if (info.sector = cell.sector_id) && (Random.float 1.0 < 0.04) then result := Exposed
          (* Long-range interaction in the different sector *)
          else if (Random.float 1.0 < 0.001) then result := Exposed

      | {origin = _; status = Infectious; sector = _} -> 
          (* Neighbor interaction in the same sector *)
          if  (info.sector = cell.sector_id) && (Random.float 1.0 < 0.1) then result := Exposed
          (* Neighbor interaction in the different sector *)
          else if (Random.float 1.0 < 0.001) then result := Exposed
      | {origin = _; status = _; sector = _} -> ()
    )

	  interactions;
	  cell.cell_status <-
	  	match cell.cell_status with
	  	| Susceptible -> if !result = Exposed then (cell.exposed_time <- cell.time; Exposed) else Susceptible
	  	| Exposed ->     if (cell.time - cell.exposed_time) < delta then Exposed else (cell.infectious_time <- cell.time; Infectious)
	  	| Infectious ->  if (cell.time - cell.infectious_time) < gamma then Infectious else Removed
	  	| Removed -> 	 Removed
	  	
(* Post T0 *)

(**************************************************************************)
(* cellular automaton                                                     *)
(**************************************************************************)
let cell_array_create tmp =
  Array.make_matrix !maxx !maxy tmp

let sector_array_create tmp =
  Array.make_matrix !sectorsize !sectorsize tmp

let get_status i j =
	(* For testing the long-range infection *)
	(*if (i = 100)&&(j = 100) then Infectious, () else Susceptible, ()*)
	if Random.float 1.0 < 0.0005 then Infectious else Susceptible


let process cellular_automaton_start
    draw_cell get_neighbors get_status cell_behavior cell_array sector_array =
  for i = 0 to !maxx - 1 dopar
    for j = 0 to !maxy - 1 dopar
      if (j mod (!sectormaxx) = 0) && (i mod (!sectormaxy) = 0) then 
        ( run (cell draw_cell get_neighbors cell_behavior
          i j (get_status i j) cell_array sector_array)
          ||
          run (sector (i/(!sectormaxx), j/(!sectormaxy)) sector_array)
        )
      else 
        ( run (cell draw_cell get_neighbors cell_behavior
          i j (get_status i j) cell_array sector_array)
        )
     
    done
  done

(**************************************************************************)
(* main                                                                   *)
(**************************************************************************)



let process main =
	Random.self_init();
	Graphics.open_graph (" "^(string_of_int (!maxx * !zoom))^"x"^
			       (string_of_int (!maxy * !zoom)));
    Graphics.auto_synchronize false;

  signal tmp_cell in
  signal tmp_sector in
	let dummy_cell = (new_cell 5 5 tmp_cell Susceptible (0,0)) in
  let dummy_sector = (new_sector C tmp_sector (0,0)) in 
		let cell_array = cell_array_create dummy_cell in
    let sector_array = sector_array_create dummy_sector in
		let draw = draw_cell_gen color_of_status
		in
		run (cellular_automaton_start
		       draw
		       get_von_neumann_neighbors
		       get_status
		       ebola
	       	 cell_array
           sector_array);
		||
		loop
			ignore (Graphics.wait_next_event [Graphics.Poll]);
			Graphics.synchronize ();
			pause;
      	end

let () = run main
